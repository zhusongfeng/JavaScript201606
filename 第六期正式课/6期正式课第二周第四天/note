1.排序思路：
    1.类数组专数组
    2.sort排序
    3.重新把排好序的数组插入页面
2.隔行换色实现思路：
    1.switch
    2.for循环+一句话%;
    3.if..else if....
3.数据和页面绑定思路：
    1.文档碎片
    2.字符串拼接
    3.for循环每次都插入，比较耗性能；
4.数字排序 ary.sort(function(a,b){return a-b}) 从小到大
         ary.sort(function(a,b){return (a-b)*-1})
 汉字排序 'a'.localCompare('b')
5.this用法总结
    1.回调函数中的this一般是window
    2.构造函数中 this-实例
    3.当触发元素身上事件的时候，会执行一个函数，函数中的this指向当前这个元素
    4.当函数执行的时候，点前面是谁this就是谁
    5.当遇到call,apply,bind的时候，以上都失效，我们可以通过他们的第一个参数改变this指向
    6.自执行函数中的this永远都是window；
6.关于表格排序的思路总结
   1）总思路
   1.获取并解析数据--ajax
   2.绑定数据
        用了两种思路：
        1.字符串拼接
        2.动态创建和文档碎片
   3.隔行换色
        1.switch
        2.if...elseif...else...
        3.for循环+一句话%的思想
        %的小技巧：有几种情况就%几；
   4.表格排序
        关于循环绑定事件2种思路：
        1.自定义属性
        2.闭包
   5.优化处理
        1.this的处理：
            1.当触发元素身上事件的时候，会执行一个函数，函数中的this指向当前这个元素
            2.call
            3.回调函数中this的处理---在回调函数外面保存_this=this变量；
        2.自定义属性存内容
            对象.flag=-1;
            没发生点击事件的时候，都*=-1;
            注意点：点击哪一列的时候，让哪一列*=-1；其他没发生点击事件的列都恢复初始状态-1；
7.正则由两部分组成：元字符+修饰符
元字符：
1）特殊含义的元字符
\ 转义
|或
() 分组
. 除了\n以外的其他字符
\n 换行
\b 单词边界： 开头结尾和空格
^ 开头
$ 结尾
[a-z] 字母
[^a-z]非字母
[abc] abc三者中的任何一个
[^abc] 除了这三个，其他中的任何一个
\d 数字 \w 字母数字下划线 \s 空格
\D 非数字 \W 非字母数字下划线 \S 非空格
2）代表次数的量词元字符
* 0到多
+ 1到多
? 0次或者1次
{n} 正好n次
{n,} n次到多次
{n,m} n到m次；
修饰符
g 全局匹配 i忽略大小写  m换行操作 多行操作
8.正则：规则 用来操作字符串（匹配和捕获）的规则；
匹配？ 看字符串是否符合我们制定的规则； reg.test()
捕获？ 把符合我们规则的字符串取出来；reg.exec() str.match(); str.replace();
9.捕获 正则有两个特点：
1）懒惰性 解决：加全局g;
2)贪婪性 解决:量词+?
10.reg.exec() 用来捕获符合我们规则的字符串，每次只能捕获到一个；捕获的这一个是个数组；
数组总共包含三项：
1）符合规则的字符串内容；
2）该内容的索引；
3）input：原始字符串；
如果exec找不到符合规则的内容的话，返回的是null;
为何exec如果不加全局g的时候，每次都捕获到第一项内容；因为 reg.lastIndex永远都是从0开始的；
11.[]的总结
1）[]里面的特殊字符没有特殊含义，代表的都是他本身的意思： + - .
2)[]中不会出现两位数
12.（）的总结
1）提高优先级
2）分组
3)(?:)只匹配不捕获；
13.？的总结
1）量词 0或1
2）解决正则的贪婪性的问题；量词+?
3)(?:)只匹配不捕获；
14.match实现的核心原理就是用exec分次捕获得到的；
match和exec的区别：
1）match一次性可以捕获到所有符合规则的内容，放在一个新数组返回；
exec每次只能捕获到一个符合规则的内容，并且以数组的形式返回，我们要的内容一般是数组第一项；
2）match不能进行小分组的捕获
exec可以进行小分组的捕获，他的小分组从索引1开始（从第二项开始）；如果没有分组，exec数组中有3项；
15.exec
1)每次只能找到一项-数组
    这个数组在没有小分组的情况，拿到这个数组只有3项：
        1.我们匹配到的内容
        2.内容的索引
        3.原始字符串
    这个数组如果有小分组
        1.我们匹配到的内容（如何大正则的内容）
        2.从第二项开始，一直到ary.length-2之前都是小分组捕获出来的内容；
        3.倒数第二项 -索引
        4.最后一项：原始字符串；
2）exec和match区别：
    1）exec存在小分组，但match没有
    2）match一次性可以匹配到所有的内容，并且都放在一个数组中
    exec只能一次次的捕获；
exec和replace运用思想是一模一样的；

16.捕获：
1）exec
2）match
3）replace
17.replace
1）如果没有正则，replace只能一次次的去匹配和替换
2）如果用了正则，就可以批量替换
replace的第二个参数，可以是个函数，函数的执行次数跟匹配成功的次数有关；
18.封装：
1）封装match
2）封装 日期格式化











