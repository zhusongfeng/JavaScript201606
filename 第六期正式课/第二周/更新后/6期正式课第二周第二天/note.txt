1.call和apply的执行步骤
    1.把call点前面的函数中的this关键字变成call的第一个参数
    2.把call点前面的函数执行；
2.bind
bind和call在传参的时候是一样的；（改变this指向，参1，参2。。。）
bind预解析机制：1.首先改变bind中的this关键字，同时把bind点前面的函数中的形参传值，然后返回一个修改过的函数；我们可以用变量去接受这个返回的函数；
          2.在需要的时候，调用返回的这个函数；
3.封装方法的思路
    1.功能：一定要明白这个方法干什么用？
    把类数组转成数组
    2.考虑是否有参数：类数组；
    3.考虑是否有返回值：数组；
    4.写核心程序
    判断浏览器是否兼容：
    思路1：属性的判断：xx.xxx; '属性名' in 对象
    思路2：try...catch...

    1.功能：把JSON格式的字符串转成JSON格式的数据（对象）
    2.考虑是否有参数：字符串
    3.考虑是否有返回值：对象
    4.判断浏览器是否兼容：思路1：属性的判断：xx.xxx; '属性名' in 对象
4.写JS的顺序
1）HTML+css一定先写好（用的假数据）
2）写JS：不是写代码，而是写思路
3）写代码；
5.从页面中拿过来的所有内容都是字符串；
6.浏览器异常捕获
    try{//执行是浏览器支持并且能正常执行的JS语句
        console.log(a)
    }catch(e){
        //当try里面的语句不能正常执行的时候，走的是catch里面的语句；
        console.log(e)//打印出错误原因
    }finally{//finally里面的语句，是无论try能否正常执行，都会走finally；所以，finally基本不用；
        console.log(111)
    }
7.三种绑定数据的思路及DOM回流
    DOM回流：当页面中的HTML发生变化的时候，会对页面中的所有内容都重新渲染；
    思路1：字符串拼接
        缺点：相当于把页面中的内容拿出来，跟我们已经拼接好的字符串str再进行字符串拼接；最后拿到新拼接好的字符串把他转化为标签，重新放入页面中；所以，以前页面中元素身上的事件就都没有了；
        优点：只引发一次DOM回流
        工作中用的最多的就是字符串拼接；
    思路2：动态创建，循环中每次插入---缺点：每循环一次，就会DOM回流一次，耗性能；
        优点：可以保留以前元素身上的事件
    思路3：动态创建+文档碎片document.createDocumentFragment();
        他只引发一次DOM回流，而且可以保留原来元素身上的事件；
8.DOM映射：1.HTML页面结构中的标签（HTML）  2.获取到的元素集合（js）
      1）当页面中的HTML标签发生变化的时候，我们不需要重新获取，JS中的元素集合就会对应的发生变化；
      2）当我们用JS操作页面中的内容的时候，页面中的标签也会相应的发生变化；
      他们两个互相影响；
9.想实现排序需要3步骤：
    1.类数组转数组；
    2.数组排序sort
    3.把排序好的数组内容，重新插入页面
10.JS的异步编程：同步和异步
同步：当前项目干不完，不会开始下一项
异步：当前项目干不完，不等他，继续执行后面的项目，等后面的项目都执行完成时候，再返回来执行当前项目；
11.4步骤
1.创建一个ajax对象
2.打开一个地址，3个参数（'get','data.txt',false）
3.响应请求 xml.readyState xml.status
4.发送请求 xml.send();




