1.固定步长的运动
    1)设置目标值和固定步长
    2）开启定时器，获取当前最新位置；在最新位置上+=step；
    3）停止条件：当最新位置+step>=target时，停止运动
    问题：不加边界值，出现反弹或滚动条
    解决办法：边界值判断
2.计算步长的运动
    1）target/duration*interval
    2）开启定时器，获取当前最新位置；在最新位置上+=step；
    3）停止条件：当最新位置+step>=target时，停止运动
    问题：不加边界值，出现反弹或滚动条
    解决办法：边界值判断
3.匀速运动：利用Linear(t,b,c,d);
    t:time
    b:begin
    c:change
    d:duration
    1)开启一个定时器，不断累加时间
    2）通过Linear公式计算当前的位置，并且重新设置新位置
    3）停止条件：当time>=duration时，把物体设置到目标值，同时停止运动
4.物体的多运动（至少写5遍以上，要求自己靠自己思路可以写出来）
    1）两个begin，两个target,两个change，1个duration，time；
    2）写出以上值是为了给Linear传参，通过公式和定时器计算最新的位置并且重新设置新位置
    3）停止条件：当time>=duration时，把物体设置到目标值，同时停止运动
5.用setTimeout实现点击左右运动：
    1）向左走向右走，取决于当前位置与目标值的大小判断
    2）如果当前位置<目标值; 当前位置+=step;反之，当前位置-=step;
    3)停止条件都是 当前位置（+/-）step>=(<=)target;直接设置物体到目标值；
    4）通过setTimeout让move方法不断的调用
    5）但以上调用 move需要传参，存在性能问题：
    在匿名函数中，如果有函数调用并且需要参数，而参数需要把匿名函数当作跳板去取参数值，这就会导致匿名函数里的东西被外面占用；形成无数个不销毁的私有作用域；
    而_move避免了匿名函数不销毁的问题；

6.关于运动的小技巧：
1）不加边界值，出现反弹或滚动条--解决办法 边界值判断
2）开启一个定时器前，先关闭定时器
3）保存定时器的全局变量，可以写在自定义属性上，避免全局变量冲突的问题和性能问题；
4）在匿名函数中，如果有函数调用并且需要参数，而参数需要把匿名函数当作跳板去取参数值，这就会导致匿名函数里的东西被外面占用；形成无数个不销毁的私有作用域；
而_move避免了匿名函数不销毁的问题；