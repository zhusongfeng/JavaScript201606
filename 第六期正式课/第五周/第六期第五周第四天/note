1.事件包括DOM0级事件和DOM2级事件
DOM2级事件在元素所属的eventTarget这个类的原型上；
2.DOM2级事件的优点：
1）可以在同一个元素，触发元素的同一个行为，执行不同的方法；
2）在DOM0级事件没有的属性，在DOM2级事件上会有；DOMContentLoaded:DOM结构的内容都加载完成
3.
$(function(){})
$(document).ready(function(){}) ---JS中的事件是DOMContentLoaded
以上两个都是当DOM结构或者HTML页面加载完成的时候，在执行其他代码
window.onload 当页面所有的元素（HTML页面结构，图片加载，音频，视频等）都加载完成
jquery中可以多次调用$(function(){})，说明他用了DOM2级事件绑定
jquery中加载完DOM结构才执行代码，说明他用了DOMContentLoaded这个事件；
4.在IE下，DOM0级事件和DOM2级事件（attachEvent）的联系和区别：
1)在触发行为时，事件都带on
2）DOM2级事件（attachEvent）,可以在同一个元素上，触发同一个行为，绑定多个方法；
5.DOM2级事件： addEventListener   attachEvent
6.DOM2级的事件机制--标准浏览器下的反映
1)在同一个元素同一个行为上，绑定多次相同的方法；浏览器默认只会保留一个
2）DOM2级事件中绑定的方法中的this，就是当前触发事件的这个元素；
3）按照绑定的先后循序，执行该元素同一个行为上绑定的方法；
.......................
在非标准浏览器下需要解决的兼容问题：
1）重复问题：如果有了，不添加；
2）this问题：call
3）顺序问题：
7.浏览器事件池
8.关于解决this问题：
在绑定事件的时候，把绑定的方法都放在一个匿名函数中，在匿名函数中通过call去改变this指向；
绑定多次，就会有多个匿名函数，我们把每个匿名函数都放在自定义属性curEle['myBind'+eventType]这个数组中；如果数组中已经有这个行为对应的方法，不做任何操作，直接return；
在解除事件绑定的时候，我们不知道应该解除数组中的哪个匿名函数；所以，在给数组中存储匿名函数之前，我们给匿名函数起个名字；
在解除事件绑定的时候，可以遍历数组中的每一项，通过判断数组中哪一项的name===eventFn;如果等于就解除一这项；同时，要删除自定义事件池的中的这个方法；为了防止数组塌陷引发的解除事件绑定的错误问题，提前保存cur=ary[i];

9.
1)首先处理浏览器的兼容性：
    在标准浏览器下，addEventListener
    在非标准浏览器下,attachEvent
2)this问题：
    不能直接在addEventListener(curEle,eventType,eventFn.call(curEle));
    为了改变this指向，我们只能在匿名函数中去改变this;
    如果直接在元素的自定义属性上定义一个属性名，专门用来存储每个匿名函数；这样会存在覆盖问题；
    所以，我们只能在自定义属性上去创建一个数组，数组中存的就是每个包裹方法的匿名函数；为了区分数组中每个匿名函数都是谁，所以给每个匿名函数都起了名字；这样，我们在解除事件绑定时候，可以根据名字解除对应的匿名函数；

关于所有DOM2级库方法的总结：
* 1）bind里做了什么事？--解决了 this问题，重复问题
*   1.处理标准浏览器和低级浏览器的兼容处理
*   2.处理this问题：把每个匿名函数（给绑定的方法改变this指向）放在定义属性这个数组中；这就是自己的事件池; 把每个匿名函数也放在系统事件池中；
*   3.为了在unbind中能够解除浏览器事件池中的匿名函数；需要在bind中给自己的事件池添加以前，给每个匿名函数起个名字 tmpFn.name=eventFn;
* 2)unbind
*   1.拿到自定义属性上的数组；
*   2.判断数组中谁的名字===eventFn;浏览器事件池解除这个匿名函数；删除数组中的这一项匿名函数；
* 1）on里想干什么事？--绑定事件 this问题， 重复问题 ，顺序问题；
*   1.创建一个自定义属性，做为数组，存的是每个行为绑定的方法；--做为自己的事件池
*   2.给元素的某个行为绑定bind一个run方法（直接把run方法放到系统事件池里了）
*   bind(curEle,eventType,run)//run方法中有一个系统传入的参数e：事件对象；run方法中的this就是curEle;
* 2）run方法里干了什么事？
*   1.核心：把元素自定义属性上的数组中的所有方法都执行了； this？事件对象？
*   2.做了低级浏览器的兼容处理；if(!e.target).....
* 3）off里干了什么事？--解除绑定
* 系统的事件池里，只有一个 run方法，如果想解除事件绑定，只要删除数组中原有的方法，run方法中就不会执行已删除的这个方法；











