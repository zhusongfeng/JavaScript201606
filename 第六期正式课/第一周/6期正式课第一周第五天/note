1.回调函数需要关注的几点
    1.回调函数：把一个函数表达式作为参数传给另一个函数；callback
    2.回调函数被调用的次数 --根据自己的需要调用n次；
    3.回调函数传参 callback(参1，参2)--如果函数定义了形参，但是回调函数中没有传实参，拿到的是undefined;
    4.回调函数中this的修改；如果想改变this指向---用call(改变this指向，参1，参2.。。。)；
    5.回调函数中有返回值吗？
2.不管是forEach还是map中都可以通过input 这个参数配合index修改我们的原数组；
3.重写：子类通过__proto__一级级往上去修改父类的属性和方法；这就是子类对父类的重写；
既然子类可以重写父类，系统为了防止子类通过__proto__去更改系统内置的属性和方法，所以在IE浏览器下，禁止我们使用__proto__;
4.继承：子类可以继承父类原有的属性和方法，但是当子类添加私有属性和方法的时候，不对父类造成影响；
    1）原型链继承：把父类的私有+公有的属性和方法，都作为子类公有的属性；
      核心：不是把父类私有+公有的属性克隆一份一模一样的给子类的公有吧；他是通过__proto__建立和子类之间的原型链，当子类的实例需要使用父类的属性和方法的时候，可以通过__proto__一级级找上去使用；
    2）call继承：把父类私有的属性和方法给了子类私有的属性和方法；
    核心思想：相当于把父类私有的属性和方法克隆了一份一模一样的给子类的私有属性；
    3）冒充继承：把父类公有的+私有的属性都作为了子类私有的属性；
    4）混合继承1：call继承+原型链继承
    call继承：把父类私有的作为自己私有的；
    原型链继承：把父类私有+公有做为公有的；
    问题：父类私有的，在子类私有+公有两个地方都存在；
    5）混合继承2：call继承+拷贝继承
    call继承：把父类私有的作为自己私有的；
    拷贝继承：通过for in循环，把父类公有的属性和方法克隆了一份一模一样的给子类公有的；
    6）寄生式组合继承：
    call继承：把父类私有的作为自己私有的；
    Object.create()思想：
        1）创建一个空类；
        2）给空类的原型上添加了父类原型的地址；（相当于把父类原型上的公有属性和方法，给了空类原型上）
        3）子类的原型上添加空类的实例；（这样，子类就可以通过__proto__去找父类公有的属性和方法；但是不受父类私有属性的影响）
---------------------------------------------------------------------
1.预解释：在当前作用域下，在JS代码执行之前，浏览器会对带var和带function进行提前声明或者定义；
2.作用域：全局作用域和私有作用域；
    1.全局作用域：当浏览器加载完html页面的时候，会形成一个供JS代码执行的环境，这个环境叫做全局作用域；全局作用域下全局变量--其实就是window的全局属性；
             全局作用域下的函数调用--其实就是window的全局方法；
    2.私有作用域：
    当函数执行的时候，会形成一个私有作用域：里面有3步骤：
        1）形参赋值
        2）预解释
        3）JS代码从上到下的执行
3.带var和带function的声明和定义不同：
带var：只声明不定义
带function：声明+定义
4.函数的变量有2部分
    1）形参
    2）函数中带var的变量；
5.带var和不带var的区别：
    带var：1）会进行预解释 2）如果是全局变量的话，带var的还是全局属性window.xx;
    不带var：1）不会进行预解释 2）在设置情况下，如果往上找找到window一直都没找到，那么他就是全局属性；
6.作用域链：当函数执行的时候，形成一个私有作用域，看这个作用域中是否定义了一个变量：
1）如果定义了：那这个变量就是私有变量，整个作用域中的此变量跟外界都没有任何关系；它都是私有变量
2）如果没定义：去上级作用域查找，找到的话就直接赋值或者获取，没找到，继续往上找。。。。找到window都没有的话
    1.如果是获取，报错 xxx is not defined;
    2.如果是设置，全局属性；
7.上级作用域：只跟当前函数对应的堆内存在哪里开辟有关，跟函数在哪里调用没有任何关系；
8.内存：堆内存和栈内存
栈内存：全局作用域和私有作用域；
堆内存：存放的是引用数据类型的值；对象：属性名和属性值； 函数：代码字符串
9.内存释放：
var aa={...}
堆内存的释放：一般情况下，堆内存都被变量占用，无法释放；
解决措施：让变量指向空指针，不再指向堆内存的地址；
栈内存释放：
    全局作用域的释放：当我们关闭页面的时候；
    私有作用域的释放：一般情况下，当函数执行完成的时候就被释放
    不释放的情况：
        1）函数中有东西被外面的变量或者其他元素占用
        2）不立即释放
10.预解释无节操：
    1）自执行函数不会进行预解释
    2）已经声明过的变量不会进行重复声明，但会重新赋值
    3）if条件语句中无论条件是否成立，都会进行预解释
    4）对=左边的带var进行声明，但不定义
    5）return返回值不会进行声明，return下面的语句不执行，但会进行声明
11.闭包：
    1）避免全局变量名冲突
    2）在闭包中修改全局变量的值，而不影响全局变量
    3）如果想影响全局变量 window.xxxx
    4) 封装 ，让外面可以拿到window.xxx=函数名；
12.this总结：
    1）触发元素事件的时候，执行一个函数，函数中的this指向当前这个元素
    2）自执行函数this--window
    3）构造函数this指向当前实例；
    4）当函数调用的时候，看前面是否有“.”，“.”前面是谁this就是谁
    5）call(),apply(),bind()
    6)回调函数中this一般指向window；
13.DOM的动态操作
    1.动态创建 document.createElement('div')
    obj.cloneNode();
    2.DOM插入
    父级.appendChild(oDiv)
    父级.insertBefore(newEle,oldEle)
    3.替换
    父级.replaceChild(newEle,oldEle)
    4.删除
    父级.removeChild(curEle);
14.子节点：childNodes
   子元素:children
15.
在数组的后面追加一项(至少两种办法)
ary.push(); ary.splice(ary.length,0,''); ary[ary.length]='';
删除数组的最后一项(至少两种办法)
ary.pop(); ary.splice(ary.length-1);ary.splice(ary.length-1,1),
ary.length--; ary.length=ary.length-1; ary.length-=1;
delete ary[ary.length-1]==>注意：可以删除数组最后一项，但是数组的长度不会发生改变；
16.克隆一份和原来一样的数组(至少两种)：
ary.splice(0); ary.slice(0)/ary.slice(); ary.concat();
17.数组从大到小排序
ary.sort(function(a,b){return b-a});
18.实现找到第n项到第m项(包括n和m)的内容，返回一个新的数组(原有数组不变)
ary.slice(n-1,m)
19.求[n-m]范围的整数
Math.round(Math.random()*(m-n)+n);
20.9种数据类型比较
    1.对象==对象 比较是地址
    2.对象==字符串 转成字符串
    3.对象==数字 转成数字
    4.对象==布尔 转成数字
    5.字符串==数字 转成数字
    6.字符串==布尔 转成数字
    7.数字==布尔 转成数字
    8.null==undefined ->true
    null===undefined ->false
    9.NaN==NaN;
21.字符串常用方法
    1.charAt
    2.charCodeAt
    3.indexOf
    4.lastIndexOf
    5.substr
    6.substring
    7.slice
    8.toUpperCase
    9.toLowerCase
    10.split
    11.replace()
    12.search()
    13.match()





