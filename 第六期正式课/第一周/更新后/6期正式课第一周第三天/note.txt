1.字符串常用方法
    charAt
    charCodeAt
    indexOf
    lastIndexOf
    substr(n,m) 从索引n开始，找m个
    substring（n,m） 从索引n到索引m，不包含m
    slice（n,m） 从索引n到索引m，不包含，有负值
    split()
    toUpperCase()
    toLowerCase()
    replace('','')
    search() 查找
    match() 匹配
2.Math常用方法
    1.Math.random ---Math.round(Math.random()*(m-n)+n);
    2.Math.floor
    3.Math.ceil
    4.Math.abs()
    5.Math.min()
    6.Math.max()
    7.Math.sqrt()开平方
    8.Math.pow() 幂次方
    9.Math.round() 四舍五入
3. 更新课件
    1.打开老师地址
    2.fork
    3.git clone 自己的远程地址
    4.git remote add teacher 老师的远程地址
    5.git remote -v
    git remote rm teacher 删除一个远程地址
    6.git remote update teacher
    7.git pull teacher master
    8.git add .
    git commit -m""
    git push origin master
4.变量和函数在预解释阶段的不同
带var:只声明不定义
带function:声明+定义
5.预解释无节操：
    1.自执行函数不进行预解释
    2.已经声明过的变量不进行重复声明，但是会重新赋值
    3.等号左边带var的只声明不定义
    4.if语句无论条件是否成立，都会进行预解释
    5.return 后面的返回值不进行预解释，但是return下面的语句虽然不执行，但是会进行预解释
6.this的3个总结
   1.自执行函数中的this永远都是window
   2.当函数被调用的时候，看前面是否有".","."前面是谁，this就是谁
   3.当触发一个元素身上的事件，执行对应的函数，函数中的this指向当前这个元素
   4.在构造函数中，this指向当前实例；
7.i++ 和 ++i
 ++i 先++再运算;
 i++ 先运算再++;
8.在预解释阶段，函数的优先级大于变量；
9.什么是面向对象：
10.对象由两部分构成：属性 和 方法；
11.面向对象的特点：
    1.封装：对于相同功能的代码，放在一个函数中，以后再用到此功能，只需要调用即可，无需再重写；避免大量冗余代码；
    专业话说：低耦合，高内聚；
    2.继承：子类继承父类原有的属性和方法；
    类：'Object','Function','Number','String','Array','RegExp','Date'.....
    3.多态：重载和重写；
    重载：在JS中不存在严格意义上的重载；但是，JS中有类似重载的功能:同一个函数，传不同的参数，实现不同的功能；
    重写：子类可以重写父类的属性和方法；
12.会学到的设计模式：单例模式，工厂模式，构造函数模式，原型模式；
13.单例模式：把描述同一事物的属性和方法，放在同一个命名空间下，避免了变量名冲突的问题；
命名空间：浏览器开辟了一个堆内存，给他分配的名字person1就是命名空间
单例模式本质：普通对象；
14.模块化开发：对于一个大型项目，项目组会分配给不同的工程师去开发（这些开发是同步进行的）；等所有人开发完成，合在一起，整个项目就完成了；
1)单例就是简单的模块化开发；
2)可以实现本模块间的相互调用：this.属性名;
3)可以实现模块之间的相互调用：模块名.属性名；
15.单例模式的优缺点：
优点：1）可以实现模块化开发 2）避免了属性名相同，以及变量名相同的冲突问题；
缺点：传统的手工作业模式，开发效率低，并且造成大量冗余代码；
解决措施：封装--工厂模式
16.工厂模式的思想：
    1.引进一批原材料----1.var obj={}; var obj=new Object();我们自己创建一个空对象
    2.对原材料进行加工---2.给空对象添加一些私有的属性和方法；
    3.输出原材料---3.输出对象 return obj;
工厂模式的本质：封装；
17.工厂模式在调用的时候，跟创建一个实例的区别：
    1）创建一个实例的时候：函数名首字母大写
    2）创建一个实例的时候： 有new ;
18.构造函数模式：--为了自定义一个类，并且可以创建一些实例；
实例 instanceOf 类；==》返回的是 boolean值；
构函数模式跟工厂模式的区别：
    1.在调用时候
    构造函数 new Person()；
    工厂模式 person();
    2.在函数体内的区别；
    构造函数：系统自动创建一个对象，等我们给对象加工完成后，系统自动输出该对象；
    工厂模式：手动创建对象，等我们给对象加工完成后，手动输出对象；
 缺点：对于相同的功能，却不相等；
 解决措施：prototype原型，把功能相同的代码，放在一个公共区间；
 19.原型模式；
 20.关于构造函数：
    1.构造函数中放的都是私有的属性和方法；
    2.就是实例和类在打交道；
    3.在创建一个实例的时候，如果不需要传参，小括号可以省略；
    4.构造函数this，永远指向当前实例；
    5.在构造函数中，实例只跟this.xxx有关系，跟变量没有任何关系；
    6.构造函数中，系统默认会为我们返回一个对象；如果我们手动返回的话：
    1）return 基本数据类型，不会造成任何影响；实例还有他的属性和方法；
    2）return 引用数据类型，会影响系统返回的对象，实例就没有他以前的属性和方法了；
    所以，不建议手动返回对象;
21.原型模式的基础知识：重中之重
    1）每一个函数数据类型（类，普通函数）上都天生自带一个属性，叫做prototype（原型），它是一个对象；
    2）prototype这个原型上，天生自带一个属性，叫做constructor,指向当前所属的类；
    constructor：类；
    3）每个对象(实例，普通对象，prototype)上，都天生自带一个属性，叫做__proto__,他指向当前实例所属的类的原型；
22.Object.prototype:都放的公有的属性和方法
hasOwnProperty:判断attr这属性是否是这个对象上的私有属性；
isPrototypeOf：obj1是否在obj2的原型链上；
propertyIsEnumerable：是否可枚举的属性；
23.
每个类都是函数数据类型；
Object是对象数据类型的基类；
24.
构造函数模式：实例 和 类；
原型模式：实例 ， 类， 原型；
构造函数里：私有的属性和方法；
prototype上：公有的属性和方法；
25.原型链查找机制：比如要查找f1.x==>对象.属性名
1）在自己的私有属性上查找，如果找到那么这个属性就是私有属性；
2）如果没找到，通过__proto__去所属类的原型上进行查找，因为原型上放的都是公有的属性和方法，所以，如果找到，这个属性就是公有的；
3）如果没找到，通过__proto__一层层往找，最终找到基类Object.prototye上，如果还没有，undefined！












